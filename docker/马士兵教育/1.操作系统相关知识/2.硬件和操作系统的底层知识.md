# 指令重排序会带来什么问题？DCL单例，到底需不需要volatile?

​		指令重排序，在多线程下，会带来问题。例如DCL单例（Double Check Lock）
​		因为可能会使用到半初始化的对象。而volatile可以禁止指令重排序

# 内核态和用户态

​		操作系统为什么要进行权限划分？很简单，为了安全。如果操作系统运行的程序可以访问任何敏感资源。那操作系统的安全性无法得到保障。
​		linux内核跑在ring 0级，用户程序跑在ring 3级，对于系统的关键访问，需要经过kernel的同意。
​		JVM是跑在用户态的

# 进程、线程、纤程

​		进程是OS分配资源的基本单位，线程是OS执行调度的基本单位。
​		进程和线程的区别：线程共享进程的内存空间，没有自己独立的内存空间
​		不同的操作系统有不同的实现，在Linux中，线程，就是一个普通的进程，是主进程的子进程。它和其它子进程共享主线程。

​		纤程：线程中的线程，它是用户态的线程，启动一个纤程，不需要与操作系统打交道。没有用户态和内核态的切换。所以他很轻量级。纤程的实现，完全参照了线程的实现，它内部也有一个栈。它的调度，来自于所在线程的调度。

## Java的Thread是怎么实现的呢？

​      就目前hotspot这样的JVM而言，它实际上就去操作系统内核起一个线程，这个Thread和操作系统内核的线程是1对1的，因此它是重量级线程，这个线程需要和操作系统内核打交道。

## Java是否支持纤程？

​      本质上而言，JVM支持纤程，所以Java也是支持的，但java没有内置的包，也就是说JDK没有，到14也还没有。目前openJDK有个loom的项目，正在尝试开发纤程。到时候有望合并到主分支上。目前而言，如果java要使用纤程，需要使用第三方包：Quasar.

## 如果要运行10000个任务，如何让运行效率最高化？

​      答：起N个线程，每个线程启动M个纤程，充分利用操作系统内核对于线程的调度，以及JVM对于用户态纤程的调度。

## 什么场景最适合用纤程？

​      很短的计算任务，不需要跟内核打交道，并发量高

## 僵尸线程和孤儿线程

​      僵尸线程：ps -ef | grep defuct
​               父进程产生子进程后，会维护子进程的一个PCB结构，子进程退出，由父进程释放。
​               如果父进程没有释放，那么子进程成为一个僵尸进程，zombie.c
​      孤儿线程：
​              子进程结束之前，父进程已经退出
​              孤儿进程会成为init进程的孩子，由1号进程维护（图形界面，一般是1457之类的）
​              orphan.c
​      关于PCB结构：PCB = Process Control Block 进程描述符，他是一个内核的数据结构，相应的进程信息都放在这个结构里。
​      每一个进程都有自己的PCB结构。

# 进程调度

​		Linux允许用户给某个进程执行自定义的调度方案（通过打给linxu内核打补丁的方式），也就是说，每个进程有自己专属的调度方案。
​		当然了，Linux内核本身提供了很多调度方案
​		调度方案的原则：最大程度压榨CPU资源

## 抢占式和非抢占式

​		非抢占式：除非进程自己让出，否则将一直运行
​		抢占式：由进程调度器强制开始或暂停某一进程的执行。
​		现在多数操作系统都是抢占式的。

## Linux内置的调度策略

​		linux2.5 经典Unix O(1)调度策略，偏向服务器，但对交互不友好
​		linux2.6.23 采用CFS完全公平调度算法Completely Fair Scheduler

​		解释：经典Unix O(1)调度策略：大致的意思是，每个进程分配一个平均的时间，例如10ms
​		CFS完全公平调度算法：大致的意思是，根据优先级不同，分配不同的时间比例。

# CPU如何区分数据和指令？

CPU到内存之间，存在一条总线。这条总线内部实际上分为三种：数据总线、地址总线、控制总线

从数据总线过来的就是数据，从地址总线过来的就是地址，从控制总线过来的就是指令。