# 缓存设计

**问题一：为什么不能把缓存当数据库来使用?**
答：缓存存储的数据量是有限的，比如Redis，无法保存超过内存大小的数据。而且通常我们应该明确两点：

1. 我们应该限制 Redis 对内存的使用量，也就是设置 maxmemory 参数
2. 我们应该根据数据特点，明确 Redis 应该以怎样的算法来驱逐数据。

所以，当数据量接近限制的最大量时，Redis会根据算法驱逐数据，这些数据就会丢失。如果这些数据只存在于redis中的话，那么这些数据就会丢失。
注意：Redis的持久化，只是对内存中数据的持久化。那些被Redis驱逐的数据，是不会存在于持久化文件中的。如果真要考虑把Redis当数据库来用，那么可以考虑Redis企业版，提供了 Redis on Flash 可以实现 Key+ 字典 + 热数据保存在内存中，冷数据保存在 SSD 中


**问题二：Redis的数据淘汰策略有哪些？建议选择哪一种？**

+ allkeys-lru，针对所有 Key，优先删除最近最少使用的 Key；
+ volatile-lru，针对带有过期时间的 Key，优先删除最近最少使用的 Key；
+ volatile-ttl，针对带有过期时间的 Key，优先删除即将过期的 Key（根据 TTL 的值）；
+ allkeys-lfu（Redis 4.0 以上），针对所有 Key，优先删除最少使用的 Key；
+ volatile-lfu（Redis 4.0 以上），针对带有过期时间的 Key，优先删除最少使用的 Key

答：其实，这些算法是 Key 范围 +Key 选择算法的搭配组合，其中范围有 allkeys 和 volatile 两种，算法有 LRU、TTL 和 LFU 三种。算法层面讲，更推荐LFU，它是根据访问频率来删除的。通常来说，访问频率少的key，更应该删除。而范围角度来说，有些key，我们不设置过期时间，其实目的就是希望它一直存在。所以volatile可能更适合大部分的业务场景。



**问题三：缓存数据的同步策略如何选择？**

+ 先更新缓存，再更新数据库
+ 先更新数据库，再更新缓存；
+ 先删除缓存，再更新数据库，访问的时候按需加载数据到缓存；
+ 先更新数据库，再删除缓存，访问的时候按需加载数据到缓存

答：”先更新数据库再删除缓存，访问的时候按需加载数据到缓存”策略是最好的。我们的目标是避免长期出现不一致。而且我们使用缓存，往往意味着我们并不需要绝对的一致性。短暂的不一致并不影响业务。



**问题四：如何解决缓存击穿时的并发问题？**
答：如果需要非常严格，只让一个线程来进行缓存的更新的话，需要用到分布式锁。但事实上，我们并不需要那么严格，我们只是要保证，不能有太多的线程同时打到数据库上。所以简单点来说，使用JDK的锁Reentrantlock，来确保一个节点只有一个线程来更新缓存就可以了。甚至可以再放宽松一点，一个节点只能有2-3个线程来更新缓存。这时候可以考虑Semaphore



**问题五：在聊到缓存并发问题时，我们说到热点 Key 回源会对数据库产生的压力问题，如果 Key 特别热的话，可能缓存系统也无法承受，毕竟所有的访问都集中打到了一台缓存服务器。如果我们使用 Redis 来做缓存，那可以把一个热点 Key 的缓存查询压力，分散到多个 Redis 节点上吗？**
答：可以考虑给热点key加前缀或者后缀

**问题六：大 Key 也是数据缓存容易出现的一个问题。如果一个 Key 的 Value 特别大，那么可能会对 Redis 产生巨大的性能影响，因为 Redis 是单线程模型，对大 Key 进行查询或删除等操作，可能会引起 Redis 阻塞甚至是高可用切换。你知道怎么查询 Redis 中的大 Key，以及如何在设计上实现大 Key 的拆分吗？**


问题六：

